<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Hans Blog</title><link href="http://www.hansliu.com/" rel="alternate"></link><link href="http://www.hansliu.com/feeds/xie-cheng-shi.atom.xml" rel="self"></link><id>http://www.hansliu.com/</id><updated>2015-03-01T06:00:00+08:00</updated><entry><title>為什麼 MVC 實作不一樣</title><link href="http://www.hansliu.com/posts/2015/03/why-do-not-mvc-pattern-look-like.html" rel="alternate"></link><updated>2015-03-01T06:00:00+08:00</updated><author><name>Hans Liu</name></author><id>tag:www.hansliu.com,2015-03-01:posts/2015/03/why-do-not-mvc-pattern-look-like.html</id><summary type="html">&lt;p&gt;這篇文章最早是用來回應 Python 社群對於 MVC 的討論內容，同時把它記錄在自己的部落格上。&lt;/p&gt;
&lt;p&gt;其原文探討的是為什麼每套 Framework 對於 MVC 設計上都有一套自己的見解，即使設計和實作上不一樣，卻都說自家的 Framework 包含（支援） MVC。&lt;/p&gt;
&lt;p&gt;在討論這個問題之前，我們首先要認識一下 MVC 的由來，至於有關 MVC 設計的細節將不是本篇的重點，對細節有興趣的人可以從我文內分享的文章或是從書本中得到更完整的說明。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;什麼是 MVC&lt;/h2&gt;
&lt;p style="font-size: 10px;"&gt;&lt;a href="http://commons.wikimedia.org/wiki/File:MVC-Process.svg#mediaviewer/File:MVC-Process.svg"&gt;&lt;img alt="MVC-Process.svg" src="http://upload.wikimedia.org/wikipedia/commons/a/a0/MVC-Process.svg" height="290" width="264"&gt;&lt;/a&gt;&lt;br&gt;圖片 "&lt;a href="http://commons.wikimedia.org/wiki/File:MVC-Process.svg#mediaviewer/File:MVC-Process.svg"&gt;MVC-Process&lt;/a&gt;" 由 &lt;a href="//commons.wikimedia.org/wiki/User:RegisFrey" title="User:RegisFrey"&gt;RegisFrey&lt;/a&gt; - &lt;span class="int-own-work"&gt;自己的作品&lt;/span&gt;。 使用來自 &lt;a href="//commons.wikimedia.org/wiki/"&gt;维基共享資源&lt;/a&gt; 的 公共領域 條款授權。&lt;/p&gt;&lt;p&gt;MVC 最早是 smalltalk 設計的一個 Pattern，其&lt;strong&gt;定義&lt;/strong&gt;與&lt;strong&gt;目的&lt;/strong&gt;與&lt;strong&gt;模擬實作&lt;/strong&gt;的方法在 Design Pattern 一書中都描述的相當清楚，有興趣可以去書店翻一下。&lt;/p&gt;
&lt;p&gt;網路上可以參照： &lt;a class="reference external" href="http://www.tutorialspoint.com/design_pattern/mvc_pattern.htm"&gt;http://www.tutorialspoint.com/design_pattern/mvc_pattern.htm&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;目的與 MVC&lt;/h2&gt;
&lt;p&gt;這邊要著重的點在於，Design Pattern 書中不是要強迫你實作的內容百分百一樣，而是要求你的實作要達到 Pattern 目的，我在這邊列出中文書上對於其目的的說明：&lt;/p&gt;
&lt;p&gt;MVC 的目的在於&lt;strong&gt;增加彈性&lt;/strong&gt;與&lt;strong&gt;再利用性&lt;/strong&gt;，同一個 model 可以搭配好幾個 view，也可以做出不會改變 model 內容的 view，同時更嚴苛的要求，view 不應該包含運算的邏輯。&lt;/p&gt;
&lt;p&gt;因此不是去追究每套 Framework 在設計上的差異去與定義比較，然後要說它的設計到底要不要叫做 MVC， 而是要去看設計之後是否能達到 MVC 目的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mvc-architecture-pattern"&gt;
&lt;h2&gt;MVC 是 Architecture Pattern&lt;/h2&gt;
&lt;p&gt;後來有人在社群裡提到 Architecture Pattern 之後，我才想到 MVC 是在 Design Pattern 一書中開頭章節就列出來的，並沒有包含在後續主要章節所描述的23個 Design Pattern 之中，其介紹上也顯示 MVC 更像是一個 Architecture Pattern。&lt;/p&gt;
&lt;p&gt;那 Design Pattern 和所謂的 Architecture Pattern 又有什麼不同呢？&lt;/p&gt;
&lt;p&gt;根據 Stackoverflow 所描述的回答，我覺得兩種 Pattern 還是從&lt;strong&gt;目的&lt;/strong&gt;和&lt;strong&gt;實作&lt;/strong&gt;兩個層面來看最容易區分。&lt;/p&gt;
&lt;p&gt;Stackoverflow 的回答可以參照： &lt;a class="reference external" href="http://stackoverflow.com/questions/1866821/is-mvc-a-design-pattern-or-architectural-pattern"&gt;http://stackoverflow.com/questions/1866821/is-mvc-a-design-pattern-or-architectural-pattern&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;節錄其中 vrluckyin 的回答，針對目的和實作上的差別都有很清楚的描述：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Design patterns say how to write code effectively.

A few benefits:

  - Easily Maintainable
  - High Re-usability
  - Readable because of abstractions

Architectural patterns say how to utilize resources effectively.

  - Parallel tasks execution like programmers and graphic designers can work parallel.
  - Multiple technologies can be utilized to build a software.

In MVC, a). Views can be created using javascript templates and also html can be used b). Controllers can be written .NET framework and c). Models can be written in Java - a java service may be used that returns only json data.

While in design pattern, a pattern can't be implemented in which code can be written in multiple technologies like AdminUser class in Java, Customer class in C#, Partners class in Php and a factory pattern in Ruby :); hmmm..so easy?:)
&lt;/pre&gt;
&lt;p&gt;除了目的就不同， Design Pattern 在實作上會存在需要使用同一種技術語言完成的先天條件，而 Architectural Pattern 則沒有這樣的限制，所以每套 Framework 只要實作出來的結果符合 MVC Pattern 的目的，並且保證使用者擁有 MVC Pattern 的優點，就算實作的方式不盡相同，也代表其包含（支援） MVC。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="MVC"></category><category term="Design Pattern"></category></entry><entry><title>使用 Process Count Supervisor + Cronjob 管理背景行程數</title><link href="http://www.hansliu.com/posts/2014/11/github-process-count-supervisor.html" rel="alternate"></link><updated>2014-11-02T17:00:00+08:00</updated><author><name>Hans Liu</name></author><id>tag:www.hansliu.com,2014-11-02:posts/2014/11/github-process-count-supervisor.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;Cronjob 很頻繁的被使用在工作排程上，不過如果無法預期排程中的 process 的執行時間，當發生 process 的執行時間超過排程預期的時候，可能會重複執行多個重複的 process，如此不但會造成系統資源的浪費，也可能發生無法預期的錯誤。&lt;/p&gt;
&lt;p&gt;為了要友善管理背景執行的 process，在網路上可以找到用 Python 撰寫的 &lt;a class="reference external" href="http://supervisord.org/index.html"&gt;Supervisor: A Process Control System&lt;/a&gt; ，Supervisor 是一套完整的 system process monitoring 工具。但是這套工具的設計是以一支 daemon process 去管理 process，並透過設定檔來操作管理 process 的細節，雖然提供很多強大的附加功能，但主要是為了維持服務的穩定，這和我想要減少使用系統資源的目標有點不同。&lt;/p&gt;
&lt;p&gt;而且這樣的工具會有一個明顯的盲點，因為 Supervisor 是利用 daemon process 去管理 process，那是不是也需要有 process 來管理 Supervisor 的 daemon process？所以最後我沒有採用 Supervisor 這套工具，而選擇自己寫一支簡單的程式。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="process-count-supervisor"&gt;
&lt;h2&gt;Process Count Supervisor&lt;/h2&gt;
&lt;p&gt;前言說完了，回到我要解決的問題，放在要如何簡單管理 process 數目，並且盡可能減少額外要執行的 process，以此概念下完成了 Process Count Supervisor 這支程式。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;每次執行時才帶入需要的 process 指令，不需要保持常駐的 daemon&lt;/li&gt;
&lt;li&gt;簡單透過參數限制最多執行的 process 數目&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="simple-use-case"&gt;
&lt;h2&gt;Simple Use Case&lt;/h2&gt;
&lt;p&gt;新建一個睡眠時間超過一分鐘的 shell script sleep.sh:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
echo '#!/bin/bash' &amp;gt; /home/yourname/sleep.sh
echo 'sleep 200' &amp;gt; /home/yourname/sleep.sh
chmod +x /home/yourname/sleep.sh
&lt;/pre&gt;
&lt;p&gt;設定 cronjob 為每分鐘執行一次，並使用 pcs.py （Process Count Supervisor） 來管理 sleep.sh:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
crontab -e
*/1 * * * * /home/yourname/pcs.py -m 1 /home/yourname/sleep.sh &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/pre&gt;
&lt;p&gt;因為每分鐘執行一次的 sleep.sh 會睡眠超過一分鐘，所以理論上兩分鐘會擁有兩支 sleep.sh 同時在背景執行，但是在 pcs.py 的管理之下，sleep.sh 會維持同時間只有一支在背景執行。&lt;/p&gt;
&lt;p&gt;詳細使用教學可以參照 Github repository 的說明。&lt;/p&gt;
&lt;p&gt;Github repository link: &lt;a class="reference external" href="https://github.com/hansliu/process-count-supervisor"&gt;https://github.com/hansliu/process-count-supervisor&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</summary><category term="Python"></category><category term="Github"></category></entry><entry><title>2014 PyCon</title><link href="http://www.hansliu.com/posts/2014/06/2014-pycon.html" rel="alternate"></link><updated>2014-06-02T23:00:00+08:00</updated><author><name>996 / Hans</name></author><id>tag:www.hansliu.com,2014-06-02:posts/2014/06/2014-pycon.html</id><summary type="html">&lt;div class="img-center"&gt;&lt;p&gt;&lt;a class="reference external" href="https://lh5.googleusercontent.com/-LR8HJ1SVLUU/U4yvHeLDgsI/AAAAAAAAKUA/h-7gWlvf7Z0/s1600/pycon2014.jpg"&gt;&lt;img alt="image0" src="https://lh5.googleusercontent.com/-LR8HJ1SVLUU/U4yvHeLDgsI/AAAAAAAAKUA/h-7gWlvf7Z0/s800/pycon2014.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p&gt;今年當然也參加 PyCon 啦！&lt;/p&gt;
&lt;p&gt;趁記憶猶新的時候，把這次聽到有趣的 library 和 framework 記錄下來。前面三項的內容摘錄自 &lt;a class="reference external" href="http://www.codedata.com.tw/social-coding/python-conference-newbie-ccr/"&gt;codedata&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="fabric"&gt;
&lt;h2&gt;fabric&lt;/h2&gt;
&lt;p&gt;當你一次管很多台電腦的時候，常常想要一鍵讓你所有機器執行數個 command。例如想要一次看所有機器的時間是否同步，看看所有電腦上的剩餘空間，或是一鍵 deploy，一鍵 rsync 等等...這個工具讓你輕鬆寫些 python script 就可以達到此目的。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.fabfile.org/"&gt;http://www.fabfile.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="docker"&gt;
&lt;h2&gt;docker&lt;/h2&gt;
&lt;p&gt;這個應該不是 Python 限定的，但是因為有場專門介紹覺得很有興趣。現在大家已經對 VM 很熟悉了，但是 Docker 算是 lightweight 的 VM，他們有 host/guest 兩層 OS，而是在 host 之上有個 docker 層，可以 load 各種 distribution 到你的機器之上。所以你很容易開一個乾淨的環境，並且把你想要的檔案透過 API 放進此 sandbox，透過 expose 你想要的 port，這樣就可以跑起一個乾淨的環境。這對於測試，或是 staging 都非常有幫助。另外他有版本控制的功能，也有各種 distribution 的 ecosystem，成熟了以後應該會是個趨勢。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.docker.io/"&gt;https://www.docker.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="thumbor"&gt;
&lt;h2&gt;thumbor&lt;/h2&gt;
&lt;p&gt;其實這是個小但是很可能會用到的工具。我們網頁常常需要切圖，但是不知道要切多大。而 thumbor 是個 gateway，只要描述:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
http://&amp;lt;thumbor-server&amp;gt;/300×200/smart/{your-host-of-image}/{your-path-to-image}
&lt;/pre&gt;
&lt;p&gt;它就會動態的產生 thumbnail，此工具搭配 CDN 可以解決很多的問題。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/thumbor/thumbor"&gt;https://github.com/thumbor/thumbor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="jieba"&gt;
&lt;h2&gt;jieba&lt;/h2&gt;
&lt;p&gt;中文分詞一直是讓人頭痛的問題，自從雅虎斷章取義工具 sunset 之後，現在主流的分詞工具之一是中研院的中文斷詞系統，但是我自己覺得沒有很好用。現在則有了新的選擇，就是結巴分詞。結巴的目標是打造最好用的 Python 分詞工具，對於需要中文分詞的 Python 使用者來說無疑是一大福音。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/fxsjy/jieba"&gt;https://github.com/fxsjy/jieba&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="mezzanine"&gt;
&lt;h2&gt;mezzanine&lt;/h2&gt;
&lt;p&gt;基於 Django 之上完成的強大的內容管理工具，keynote speaker 有用 wordpress 當做比較的對象，架設內容網站的選擇之一。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/stephenmcd/mezzanine"&gt;https://github.com/stephenmcd/mezzanine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="networkx"&gt;
&lt;h2&gt;networkx&lt;/h2&gt;
&lt;p&gt;一個描繪點與線結構用的繪圖工具，如果有需要把複雜的網路架構圖像化的可以參考。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://networkx.github.io/"&gt;https://networkx.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="Python"></category></entry><entry><title>使用 Name Expansion + Fabric 同時部屬多台機器</title><link href="http://www.hansliu.com/posts/2014/04/github-name-expansion.html" rel="alternate"></link><updated>2014-04-26T23:00:00+08:00</updated><author><name>Hans Liu</name></author><id>tag:www.hansliu.com,2014-04-26:posts/2014/04/github-name-expansion.html</id><summary type="html">&lt;p&gt;前陣子為了完成 Fabric 同時部屬多台機器的功能，寫了一個字串展開的小工具。&lt;/p&gt;
&lt;p&gt;使用 python regular expression 來實作，讓使用者可以利用逗號、數字、括弧將字串批次展開。&lt;/p&gt;
&lt;p&gt;簡單的 use case:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; from name_expansion import NameExpansionCore
&amp;gt;&amp;gt;&amp;gt; ne = NameExpansionCore()

&amp;gt;&amp;gt;&amp;gt; host = '[tw,hk][1-2].host[3,5].com'
&amp;gt;&amp;gt;&amp;gt; host_list = list([host])
&amp;gt;&amp;gt;&amp;gt; for match in ne.parse(host):
...   host_list = ne.expand(match, host_list)
&amp;gt;&amp;gt;&amp;gt; host_list
['tw1.host3.com', 'hk1.host3.com', 'tw1.host5.com', 'hk1.host5.com',
'tw2.host3.com', 'hk2.host3.com', 'tw2.host5.com', 'hk2.host5.com']
&lt;/pre&gt;
&lt;p&gt;Fabric 要部屬的機器是儲存在 env.hosts 裡面，型態是 list，所以我們只要在 fabfile.py 加入一個 method，將 Name expansion 批次展開的結果回存到 env.hosts 裡。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def h(curr_host):
  ne = NameExpansionCore()
  host_list = list([curr_host])
  for match in ne.parse(curr_host):
    host_list = ne.expand(match, host_list)
  env.hosts = host_list
&lt;/pre&gt;
&lt;p&gt;接著我們就可以透過 Fabric 內建指令 fab，同時指定多台機器做部屬的動作，不過執行部屬的動作是循序的，並不是平行的。&lt;/p&gt;
&lt;pre class="literal-block"&gt;
fab h:host[1-3].com deploy
&lt;/pre&gt;
&lt;p&gt;詳細使用教學可以參照 Github repository 的說明。&lt;/p&gt;
&lt;p&gt;Github repository link: &lt;a class="reference external" href="https://github.com/hansliu/name-expansion"&gt;https://github.com/hansliu/name-expansion&lt;/a&gt;&lt;/p&gt;
</summary><category term="Python"></category><category term="Github"></category></entry></feed>